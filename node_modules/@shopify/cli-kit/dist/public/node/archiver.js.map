{"version":3,"file":"archiver.js","sourceRoot":"","sources":["../../../src/public/node/archiver.ts"],"names":[],"mappings":"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","sourcesContent":["import {relativePath, joinPath} from './path.js'\nimport {glob, removeFile} from './fs.js'\nimport {outputDebug, outputContent, outputToken} from '../../public/node/output.js'\nimport archiver from 'archiver'\nimport {createWriteStream, readFileSync, writeFileSync} from 'fs'\nimport {tmpdir} from 'os'\nimport {randomUUID} from 'crypto'\n\ninterface ZipOptions {\n  /**\n   * The absolute path to the directory to be zipped.\n   */\n  inputDirectory: string\n\n  /**\n   * The absolute path to the output zip file.\n   */\n  outputZipPath: string\n\n  /**\n   * Pattern(s) to match when adding files to zip, uses glob expressions.\n   */\n  matchFilePattern?: string | string[]\n}\n\n/**\n * It zips a directory and by default normalizes the paths to be forward-slash.\n * Even with forward-slash paths, zip files should still be able to be opened on\n * Windows.\n *\n * @param options - ZipOptions.\n */\nexport async function zip(options: ZipOptions): Promise<void> {\n  const {inputDirectory, outputZipPath, matchFilePattern = '**/*'} = options\n  outputDebug(outputContent`Zipping ${outputToken.path(inputDirectory)} into ${outputToken.path(outputZipPath)}`)\n  const pathsToZip = await glob(matchFilePattern, {\n    cwd: inputDirectory,\n    absolute: true,\n    dot: true,\n    followSymbolicLinks: false,\n  })\n\n  return new Promise((resolve, reject) => {\n    const archive = archiver('zip')\n\n    const output = createWriteStream(outputZipPath)\n    output.on('close', () => {\n      resolve()\n    })\n    archive.on('error', (error) => {\n      reject(error)\n    })\n    archive.pipe(output)\n\n    for (const filePath of pathsToZip) {\n      const fileRelativePath = relativePath(inputDirectory, filePath)\n      archive.file(filePath, {name: fileRelativePath})\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    archive.finalize()\n  })\n}\n\nexport interface BrotliOptions {\n  /**\n   * The directory to compress.\n   */\n  inputDirectory: string\n\n  /**\n   * The path where the compressed file will be saved.\n   */\n  outputPath: string\n\n  /**\n   * An optional glob pattern to match files.\n   */\n  matchFilePattern?: string | string[]\n\n  /**\n   * Brotli compression level (0-11, default: 11).\n   */\n  level?: number\n}\n\n/**\n * Options for decompressing a Brotli compressed tar archive.\n */\nexport interface DecompressionOptions {\n  /**\n   * Path to the compressed file.\n   */\n  inputFile: string\n\n  /**\n   * Directory where files should be extracted.\n   */\n  outputDirectory: string\n}\n\n/**\n * It compresses a directory with Brotli.\n * First creates a tar archive to preserve directory structure,\n * then compresses it with Brotli.\n *\n * @param options - BrotliOptions.\n */\nexport async function brotliCompress(options: BrotliOptions): Promise<void> {\n  const tempTarPath = joinPath(tmpdir(), `${randomUUID()}.tar`)\n\n  try {\n    // Create tar archive using archiver\n    await new Promise<void>((resolve, reject) => {\n      const archive = archiver('tar')\n      const output = createWriteStream(tempTarPath)\n\n      output.on('close', () => resolve())\n      archive.on('error', (error) => reject(error))\n      archive.pipe(output)\n\n      glob(options.matchFilePattern ?? '**/*', {\n        cwd: options.inputDirectory,\n        absolute: true,\n        dot: true,\n        followSymbolicLinks: false,\n      })\n        .then((pathsToZip) => {\n          for (const filePath of pathsToZip) {\n            const fileRelativePath = relativePath(options.inputDirectory, filePath)\n            archive.file(filePath, {name: fileRelativePath})\n          }\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          archive.finalize()\n        })\n        .catch((error) => reject(error))\n    })\n\n    const tarContent = readFileSync(tempTarPath)\n    const brotli = await import('brotli')\n    const compressed = brotli.default.compress(tarContent, {\n      quality: 7,\n      mode: 0,\n    })\n\n    if (!compressed) {\n      throw new Error('Brotli compression failed')\n    }\n\n    writeFileSync(options.outputPath, compressed)\n  } finally {\n    try {\n      await removeFile(tempTarPath)\n      // eslint-disable-next-line no-catch-all/no-catch-all\n    } catch (error) {\n      outputDebug(outputContent`Failed to clean up temporary file: ${outputToken.path(tempTarPath)}`)\n    }\n  }\n}\n"]}